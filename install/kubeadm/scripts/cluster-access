#!/bin/bash

# Creation of a Private Key and a Certificate Signing Request (CSR)
openssl genrsa -out dave.key 4096

# 
cat <<EOF > csr.cnf
[ req ]
default_bits = 2048
prompt = no
default_md = sha256
distinguished_name = dn

[ dn ]
CN = dave
O = dev

[ v3_ext ]
authorityKeyIdentifier=keyid,issuer:always
basicConstraints=CA:FALSE
keyUsage=keyEncipherment,dataEncipherment
extendedKeyUsage=serverAuth,clientAuth
EOF

openssl req -config ./csr.cnf -new -key dave.key -nodes -out dave.csr

cat <<EOF > csr.yaml
apiVersion: certificates.k8s.io/v1beta1
kind: CertificateSigningRequest
metadata:
  name: mycsr
spec:
  groups:
  - system:authenticated
  request: \${BASE64_CSR}
  usages:
  - digital signature
  - key encipherment
  - server auth
  - client auth
EOF

# Encoding the .csr file in base64
export BASE64_CSR=$(cat ./dave.csr | base64 | tr -d '\n')

# Substitution of the BASE64_CSR env variable and creation of the CertificateSigninRequest resource
cat csr.yaml | envsubst | kubectl apply -f -

# Check
k get csr

# Approve
kubectl certificate approve mycsr

# Extract Certificate
kubectl get csr mycsr -o jsonpath='{.status.certificate}' \
  | base64 --decode > dave.crt

# Show Certificate Information
openssl x509 -in ./dave.crt -noout -text

# Create a Namespace
kubectl create ns development

cat <<EOF > role.yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: development
  name: dev
rules:
- apiGroups: [""]
  resources: ["pods", "services"]
  verbs: ["create", "get", "update", "list", "delete"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["create", "get", "update", "list", "delete"]
EOF

kubectl apply -f role.yaml

cat <<EOF > role-binding.yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: dev
  namespace: development
subjects:
- kind: User
  name: dave
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: dev
  apiGroup: rbac.authorization.k8s.io
EOF

kubectl apply -f role-binding.yaml

cat <<EOF > kubeconfig.tpl
apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority-data: \${CLUSTER_CA}
    server: \${CLUSTER_ENDPOINT}
  name: \${CLUSTER_NAME}
users:
- name: \${USER}
  user:
    client-certificate-data: \${CLIENT_CERTIFICATE_DATA}
contexts:
- context:
    cluster: \${CLUSTER_NAME}
    user: dave
  name: \${USER}-\${CLUSTER_NAME}
current-context: \${USER}-\${CLUSTER_NAME}
EOF

# User identifier
export USER="dave"

# Cluster Name (get it from the current context)
export CLUSTER_NAME=$(kubectl config current-context | awk -F "@" '{ print $2 }')

# Client certificate
export CLIENT_CERTIFICATE_DATA=$(kubectl get csr mycsr -o jsonpath='{.status.certificate}')

# Cluster Certificate Authority
export CLUSTER_CA=$(kubectl config view --raw -o json | jq -r '.clusters[] | select(.name == "${CLUSTER_NAME}") | .cluster."certificate-authority-data"')

# API Server endpoint
export CLUSTER_ENDPOINT=$(kubectl config view --raw -o json | jq -r '.clusters[] | select(.name == "'$(kubectl config current-context)'") | .cluster."server"')

echo "USER.......................: ${USER}" && \
echo "CLUSTER_NAME...............: ${CLUSTER_NAME}" && \
echo "CLIENT_CERTIFICATE_DATA....: ${CLIENT_CERTIFICATE_DATA}" && \
echo "CLUSTER_CA.................: ${CLUSTER_CA}" && \
echo "CLUSTER_ENDPOINT...........: ${CLUSTER_ENDPOINT}"
